# Quiz Modulo B - Problemi ed Algoritmi

## üìö **Istruzioni**
- Rispondere alle domande scegliendo la risposta corretta
- Ogni domanda ha una sola risposta corretta
- Punteggio: 1 punto per risposta corretta
- Punteggio minimo per superare il quiz: 70% (14/20)

---

## **Domanda 1** 
Qual √® il primo passo nella metodologia di risoluzione dei problemi?

A) Scrivere il codice  
B) Testare la soluzione  
C) Comprendere completamente il problema  
D) Scegliere il linguaggio di programmazione  

**Risposta corretta:** C

---

## **Domanda 2**
Cosa significa "Divide et Impera"?

A) Dividere il team di sviluppo  
B) Scomporre un problema complesso in sottoproblemi pi√π semplici  
C) Separare il codice in pi√π file  
D) Utilizzare pi√π algoritmi contemporaneamente  

**Risposta corretta:** B

---

## **Domanda 3**
Qual √® la complessit√† temporale del Bubble Sort nel caso peggiore?

A) O(n)  
B) O(n log n)  
C) O(n¬≤)  
D) O(2‚Åø)  

**Risposta corretta:** C

---

## **Domanda 4**
Quale algoritmo di ordinamento ha sempre complessit√† O(n¬≤)?

A) Bubble Sort  
B) Selection Sort  
C) Insertion Sort  
D) Quick Sort  

**Risposta corretta:** B

---

## **Domanda 5**
In quale caso l'Insertion Sort √® pi√π efficiente?

A) Array ordinato al contrario  
B) Array casuale  
C) Array gi√† ordinato o quasi ordinato  
D) Array con molti duplicati  

**Risposta corretta:** C

---

## **Domanda 6**
Cosa rappresenta la notazione Big O?

A) Il tempo esatto di esecuzione  
B) La memoria utilizzata  
C) La crescita asintotica della complessit√†  
D) Il numero di linee di codice  

**Risposta corretta:** C

---

## **Domanda 7**
Quale delle seguenti √® una caratteristica del Selection Sort?

A) √à stabile  
B) √à adattivo  
C) Fa il numero minimo di scambi  
D) Termina prima se l'array √® ordinato  

**Risposta corretta:** C

---

## **Domanda 8**
Cos'√® un algoritmo stabile?

A) Un algoritmo che non va mai in crash  
B) Un algoritmo che mantiene l'ordine relativo degli elementi uguali  
C) Un algoritmo con complessit√† costante  
D) Un algoritmo deterministico  

**Risposta corretta:** B

---

## **Domanda 9**
Quale algoritmo √® considerato "adattivo"?

A) Selection Sort  
B) Bubble Sort (ottimizzato)  
C) Insertion Sort  
D) Tutte le precedenti  

**Risposta corretta:** C

---

## **Domanda 10**
In un array di 1000 elementi, quanti confronti fa al massimo il Selection Sort?

A) 1000  
B) 499500  
C) 1000000  
D) 2000  

**Risposta corretta:** B

---

## **Domanda 11**
Quale metodologia √® pi√π efficace per affrontare problemi complessi?

A) Provare diverse soluzioni casualmente  
B) Iniziare subito a programmare  
C) Analisi sistematica e decomposizione  
D) Copiare soluzioni esistenti  

**Risposta corretta:** C

---

## **Domanda 12**
Cosa indica una complessit√† O(1)?

A) L'algoritmo esegue 1 operazione  
B) L'algoritmo ha complessit√† costante  
C) L'algoritmo funziona solo con 1 elemento  
D) L'algoritmo √® molto lento  

**Risposta corretta:** B

---

## **Domanda 13**
Quale di questi NON √® un algoritmo di ordinamento?

A) Bubble Sort  
B) Binary Search  
C) Selection Sort  
D) Insertion Sort  

**Risposta corretta:** B

---

## **Domanda 14**
In quale fase si dovrebbe scrivere lo pseudocodice?

A) Prima di comprendere il problema  
B) Dopo aver scritto il codice  
C) Durante la progettazione della soluzione  
D) Solo se richiesto dall'insegnante  

**Risposta corretta:** C

---

## **Domanda 15**
Qual √® il vantaggio principale dell'Insertion Sort?

A) √à il pi√π veloce in assoluto  
B) Usa meno memoria  
C) √à efficiente per array piccoli e quasi ordinati  
D) Non fa mai errori  

**Risposta corretta:** C

---

## **Domanda 16**
Cosa significa che un algoritmo √® "in-place"?

A) Funziona solo sul posto di lavoro  
B) Non richiede memoria aggiuntiva significativa  
C) √à scritto in un solo file  
D) Non pu√≤ essere spostato  

**Risposta corretta:** B

---

## **Domanda 17**
Quale approccio √® migliore per il debugging?

A) Riscrivere tutto il codice  
B) Testare casi limite e utilizzare print statement  
C) Ignorare gli errori  
D) Chiedere sempre aiuto  

**Risposta corretta:** B

---

## **Domanda 18**
In O(n¬≤), cosa rappresenta 'n'?

A) Il numero di algoritmi  
B) La dimensione dell'input  
C) Il numero di variabili  
D) Il tempo in secondi  

**Risposta corretta:** B

---

## **Domanda 19**
Quale situazione rende il Bubble Sort pi√π efficiente?

A) Array completamente casuale  
B) Array ordinato al contrario  
C) Array gi√† ordinato con l'ottimizzazione del flag  
D) Array con tutti elementi uguali  

**Risposta corretta:** C

---

## **Domanda 20**
Qual √® l'obiettivo principale dell'analisi della complessit√†?

A) Rendere il codice pi√π complicato  
B) Confrontare l'efficienza degli algoritmi  
C) Aumentare il numero di operazioni  
D) Usare pi√π memoria  

**Risposta corretta:** B

---

## üìä **Valutazione**

### Punteggio:
- **18-20 punti:** Eccellente! Padronanza completa dei concetti
- **16-17 punti:** Ottimo! Buona comprensione con piccole lacune
- **14-15 punti:** Buono! Livello minimo raggiunto, rivedere alcuni concetti
- **12-13 punti:** Sufficiente! Necessario ripasso approfondito
- **< 12 punti:** Insufficiente! Rivedere tutto il modulo

### Argomenti da rivedere in base agli errori:
- **Domande 1-2, 11, 14:** Metodologia di problem solving
- **Domande 3-5, 7, 9-10, 15-16:** Algoritmi di ordinamento
- **Domande 6, 12, 18, 20:** Complessit√† computazionale
- **Domande 8, 13:** Concetti generali di algoritmi
- **Domande 17, 19:** Ottimizzazione e debugging

---

## üéØ **Suggerimenti per il miglioramento**

1. **Se hai sbagliato domande sulla metodologia:**
   - Rileggi il capitolo sulla risoluzione sistematica dei problemi
   - Pratica l'analisi di problemi seguendo i 6 passi

2. **Se hai sbagliato domande sugli algoritmi:**
   - Implementa manualmente tutti e tre gli algoritmi
   - Confronta le prestazioni con array di diverse dimensioni

3. **Se hai sbagliato domande sulla complessit√†:**
   - Studia la notazione Big O
   - Conta manualmente le operazioni per array piccoli

4. **Studio consigliato:**
   - Rivedere teoria e esempi
   - Completare tutti gli esercizi
   - Implementare varianti degli algoritmi
